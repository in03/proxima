{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Proxima","text":"<p> Davinci Resolve proxies meets distributed-computing! </p> <p> </p> <p>Documentation: https://in03.github.io/proxima/</p> <p>Source Code: https://github.com/in03/proxima</p> <p>Note</p> <p>This documentation is a work in progress! Things are constantly changing here. If something isn't working as it should  or you have any questions about Proxima or the documentation, please start a  Q&amp;A discussion on GitHub.</p> <p>Proxima is a CLI tool designed to make transcoding proxies for DaVinci Resolve a breeze \ud83d\ude0e\ud83d\udc4c.</p> <p></p> <p>Only create proxies for footage used in your timeline - not entire subfolders! Once finished encoding, proxies are automatically linked.</p> <p>Launch Proxima on as many computers as you have free and it'll pool all the resources together to encode multiple proxies at once. Best of all, you don't need any extra licenses!</p> <p>Only have one computer?</p> <p>No Worries! Depending on your chosen settings, Proxima can run as many workers as logical CPU cores. A 12-core / 24-thread machine could do 24 proxies at once! Encoding can also run entirely on the CPU, leaving GPU-heavy Resolve with plenty of resources to continue editing while you pump out proxies. </p>"},{"location":"#key-features","title":"Key Features","text":"<p>It's gutsy \u26a1:</p> <ul> <li>Distributed computing - Use multiple computers to share the load, if you have them. Proxima can use as many as you have - no limit.</li> <li>Background encoding - Encode in the background and edit in Resolve at the same time. Choose a CPU-heavy codec and Resolve will take a minimal hit.</li> <li>Multiprocessing - Each worker runs a single encoding process. Start several workers on a single machine or just a couple if it's an older machine. Easy resource management.</li> <li>Scalable - Start more workers at any time and they'll get busy. Stop workers at any time and unfinished jobs will be requeued for another worker to pick up.</li> <li>Multiple codec support - Anything ffmpeg supports, Proxima supports - including ProRes on Windows! (Grade 10-bit without switching to camera originals) </li> <li>Timeline based queueing - Easily queue only what you need. Don't choose between navigating messy folders or transcoding too much footage. Save space and time.</li> </ul> <p>But smart \ud83e\uddd0:</p> <ul> <li>Resolve clip attributes support - Generated proxy media inherits orientation, data-levels, and other clip attributes from the original source media in Resolve.</li> <li>Automatic linking - Proxima automatically links generated proxies to the correct media pool items after encoding.</li> <li>Intelligent handling - Proxima intelligently searches for existing proxies, always picking the newest one - even ones made by other applications. It's also careful in handling offline and orphaned proxies. </li> <li>Advanced user configuration - Simple YAML configuration with settings for source media whitelisting (by framerate, extension type), cross-platform path-mapping and lots more!</li> <li>Easy progress tracking - A nice pretty progress bar to display aggregate task progress, discrete task completion worker utilisation + desktop notifications. Flower for advanced metrics and a dedicated web-app on the way.</li> </ul>"},{"location":"#coming-soon","title":"Coming soon!","text":""},{"location":"#usage","title":"Usage","text":"<p>Check out the Getting Started guide for a quick setup tutorial. Otherwise, here are the basics for reference.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>proxima queue</code>                                - Queue proxies from the currently open DaVinci Resolve timeline</li> <li><code>proxima work [Optional: number of workers]</code>   - Launch some local workers</li> <li><code>proxima config</code>                               - Open user settings configuration file for editing</li> <li><code>proxima purge</code>                                - Purge all tasks from Celery according to VC key</li> <li><code>proxima celery [celery command]</code>             - Pass commands to Celery buried in venv</li> <li><code>proxima -- help</code></li> </ul>"},{"location":"Development/Road%20Map/","title":"Road Map","text":"<p>Proxima has a few places it wants to go!</p>"},{"location":"Development/Road%20Map/#2022","title":"2022","text":""},{"location":"Development/Road%20Map/#refactor-job-handling","title":"Refactor job-handling","text":"<p>I'm hoping to focus on a large scale refactor of job-handling. In the early days, Proxima was just two scripts: One that dumped clip metadata into a text file, and another that watched a directory for those text files and encoded everything in them. The first computer to take the job would change the <code>status</code> flag in the text file and get going. Of course we had all sorts of issues with op-locks, race conditions and unhandled exceptions...</p> <p>Some of that legacy code has remained. Clip attributes are saved into dictionaries and extended later with project and timeline metadata. There's no typing nor dynamic attributes, just good old fashioned data. While the data passed by Resolve's API doesn't require the same kind of validation that user input requires,  it's still difficult to extend or refactor code around job handling, so I'd like to rewrite them as data-classes.</p>"},{"location":"Development/Road%20Map/#improved-cli-commands","title":"Improved CLI commands","text":"<p>The CLI commands in Proxima are simple: <code>queue</code> to add jobs, <code>work</code> to consume them, <code>purge</code> to clear them and <code>celery</code> to pass in advanced commands. I must admit my use case has not changed much over the years. We queue jobs straight from the timeline because it works for us. I don't really know what works for everyone else. So if you use Proxima, feel free to tell me.</p> <p>I figure some more options would be fitting however.</p>"},{"location":"Development/Road%20Map/#interactive-timeline-queuing","title":"Interactive timeline queuing","text":"<p>Currently <code>queue</code> always refers to the active timeline in the current project. That works nicely. But what if you want to queue all the timelines? Or timelines matching a pattern? Or be given a list and select at will? See issue #161</p>"},{"location":"Development/Road%20Map/#2023","title":"2023","text":""},{"location":"Development/Road%20Map/#split-and-stitch-encoding","title":"Split and stitch encoding","text":"<p>Split and stitch encoding or \"chunking\" allows source media to be divided into time-range \"chunks\" for more workers to work on before being concatenated as a single file once all are finished. Let me explain why this is a good idea.</p> <p>A single worker can encode many proxies simultaneously, but a a single proxy cannot be encoded by many workers simultaneously.  This can mean a lot of idle processing power when encoding media with a long duration. All the short media will finish first and the long media will be left to individual workers. Chunking means we can divide the work evenly and win back all that processing power.</p>"},{"location":"Development/Road%20Map/#considerations","title":"Considerations","text":"<p>This is a huge undertaking. I've managed to get it working as a proof of concept locally, but to integrate it with Proxima is a different story.  Integration will depend on the aforementioned \"job-handling refactor\". There's not much we can do about the complexity besides simplify existing code, try to follow best practices and model after good examples of similar systems - which unfortunately seem scarce. If anyone knows of any please let me know! </p> <p>Concatenation is a fast operation but is limited by disk speed. The overhead can be minimised by only chunking source media over a certain duration.  Since disk-speed is an environmental factor, the exact duration of a file that is worth chunking will differ for each system.  We can provide a good default value in settings but leave it up to the end user to configure. </p>"},{"location":"Development/Road%20Map/#implementation-proposal","title":"Implementation proposal","text":"<pre><code>graph TD;\n    A[Proxima CLI]--&gt; R\n    A --&gt; S(Get setting:&lt;br&gt;duration_worth_chunking)\n    S --&gt; |45 seconds| D[Jobs]\n    R[Resolve API&lt;br&gt;- Project &lt;br&gt;- Timeline&lt;br&gt;- Clip attributes] --&gt; D\n    D --&gt; |45 seconds|T[Create encoding tasks:&lt;br&gt;chunks / full-duration]\n    T --&gt; |Tasks that are chunks| C[Wrap as chord:&lt;br&gt; task,&lt;br&gt; concat callback]\n    C --&gt; G[Wrap as group:&lt;br&gt;- chords&lt;br&gt;- full-duration]\n    T --&gt; |Tasks that are&lt;br&gt;full-duration|G\n    G --&gt; Q[Queue tasks]\n    Q --&gt; P[\"Progress discrete completion:&lt;br&gt;len([x for x in results if x.ready)\"]</code></pre> <ol> <li>Run <code>proxima queue</code> </li> <li>Get the <code>duration_worth_chunking</code> setting value from user settings</li> <li>Get the project, timeline and source media metadata from Resolve's API</li> <li>Restructure existing jobs as \"chunks\" depending on source-media duration.</li> <li>Wrap chunked jobs as chords with a concatenate callback</li> <li>Wrap all jobs in a group</li> <li>Worker side progress displays encoding progress-bar of current chunk and discrete completion of current chord </li> <li>Queuer side progress displays total average progress-bar and completion based on status of chords AsyncResults and standard AsyncResults</li> </ol>"},{"location":"Development/Road%20Map/#proxy-presets","title":"Proxy presets","text":"<p>The ability to create multiple encoding presets would allows us to set up different settings for different purposes.  Like h.264 for a project we can send over the internet? Or high quality archival of select takes.  We could also do this with Resolve's individual clip export from the delivery page, but to achieve distributed encoding, you'd still need more licenses.  That might be of interest to others.</p> <p>It also means we can preconfigure some ideal default settings that work for different users as good starting points.  say a ProRes preset for Mac users, DNxHD preset for Windows, h.264/5 for archival (a lot of fiddly settings we can disambiguate). We can add comments to explain any unintiutive necessities in the ffmpeg settings. </p> <pre><code>edit_proxy:\nffmpeg_loglevel: \"error\"\ncodec: \"dnxhd\"\nvertical_res: 720\nprofile: \"dnxhd_sq\"\npix_fmt: \"yuv422p\"\naudio_codec: \"pcm_s16le\" audio_samplerate: \"48000\" misc_args: [-\"hide_banner\", -\"stats\"] ext: \".mov\"\nthreads: 2\n\nportable_proxy:\nffmpeg_loglevel: \"info\"\ncodec: \"x264\"\nvertical_res: 1080\nprofile: \"slow\"\n...\next \".mp4\"\nthreads: \"auto\" # x264 handles best\n\nportable_archive:\nffmpeg_loglevel: \"info\"\ncodec: \"x265\"\nvertical_res: 2160\nprofile: \"very-slow\"\n...\next \".mp4\"\nthreads: \"auto\" # x264 handles best\n</code></pre>"},{"location":"Development/Road%20Map/#worker-overrides","title":"Worker Overrides","text":"<pre><code># Override queuer settings\noverrides:\n# Use wildcard matching\n# Latest overrides\npresets:\n*:\nvertical_res: 720\n\n*proxy: vertical_res: 1080\nthreads: 2\n\n*archive:\nthreads: 1\n\nportable_proxy:\nthreads: 2 # Prioritizes last override\nvertical_res: 720\n</code></pre>"},{"location":"Development/contributing/","title":"How to Contribute","text":"<p>Hi there! And thanks for checking out this contribution guide. If you're considering helping out, it's greatly appreciated \u2728\u2764\ufe0f </p> <p>Note</p> <p>Proxima is an application used everyday by myself and my editing team. While it may not be at a major release yet, it is used heavily in a production environment. If you have any questions about its development or usage please start a discussion or if you have a problem, open an issue.</p> <p>If you're not into coding but you'd still like to help, you can:</p> <ul> <li>Contribute wikis, guides and other sorts of documentation to help others use Proxima</li> <li>Contribute icons, graphics and other visual goodies to make Proxima feel more accessible</li> <li>Contribute usage feedback; bugs, questions, concerns, complaints, queries, suggestions</li> <li>And if you haven't already, please consider starring the repo! \u2728</li> </ul>"},{"location":"Development/contributing/#preferred-practices-tools-and-styles","title":"Preferred Practices, Tools and Styles","text":"<p>Below are the building blocks of Proxima's development environment. Everyone does things differently and suggestions for improvement are always welcome, but consistency is important! Please make sure you're familiar with the following \ud83d\ude0e\ud83d\udc4d</p>"},{"location":"Development/contributing/#git-basics","title":"Git basics","text":""},{"location":"Development/contributing/#issues","title":"Issues","text":""},{"location":"Development/contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a problem, search if an issue already exists. If a related issue doesn't exist, you can open a new issue using a relevant issue form. </p>"},{"location":"Development/contributing/#solve-an-issue","title":"Solve an issue","text":"<p>Scan through our existing issues to find one that interests you. You can narrow down the search using <code>labels</code> as filters. See Labels for more information. As a general rule, we don\u2019t assign issues to anyone. If you find an issue to work on, you are welcome to open a PR with a fix.</p>"},{"location":"Development/contributing/#make-changes","title":"Make Changes","text":"<p>To make changes you'll have to clone the repo and set up the dev environment, to do so you'll need the following tools: - git - poetry - python &gt;=3.10 | python 3.6 (for legacy resolve-17 branch) - DaVinci Resolve Studio with scripting enabled - preferred code editor (recommend VSCode)</p>"},{"location":"Development/contributing/#branching-workflow","title":"Branching workflow","text":"<p>Currently this repo does not use a 'develop' branch, just a 'main' branch with multiple 'topic' branches. Any time a new feature is to be added or bug is to be fixed, a GitHub issue must exist and a new branch created named after this issue, with the syntax 'topic-type/issue-number/brief-description'. Hyphens instead of spaces, slashes to separate tokens. i.e:</p> <pre><code>git branch feat/103/chunking-support\n</code></pre> <p>The topic serves to give a quick indication of the scope and longevity of the branch and help make a semantically-versioned pull-request process quicker. The issue number links to the issue complete with all comments and discussion that detail exactly what work needs to be completed. The brief description should be as short as possible and serves to remind others what the branch addresses at a glance, without having to look up the issue number. Otherwise it can be easy to work on a branch only to find out later that it was the wrong one. Recommended topic types are:</p> <ul> <li>feat (a single feature or enhancement to be implemented)</li> <li>bug (a single bug to be fixed)</li> <li>WIP (a long-running idea or feature with potentially multiple moving parts, not to be finished with anytime soon)</li> <li>junk (a test/experimental branch to play around with that was never designed to be merged with main)</li> </ul>"},{"location":"Development/contributing/#collaborating-with-pull-requests","title":"Collaborating with Pull Requests","text":""},{"location":"Development/contributing/#poetry","title":"Poetry","text":"<p>Poetry manages dependency resolution, build/packaging/deployment and development virtual environment. To develop Proxima you will need poetry installed. Follow instructions for installation here: https://python-poetry.org/</p>"},{"location":"Development/contributing/#conventional-commits","title":"Conventional Commits","text":"<p>This repo uses conventional commit style. Future intentions are to automate semantically-versioned releases using 'BREAKING CHANGE' footers to bump a major version, 'feat:' to bump a minor version and 'bug:' to bump a patch version. Other types do not bump semantic version numbers. Non-conventional commits will not fail checks, so they are still supported, but they are not recommended.  The following commit types in particular are recommended:</p> <ul> <li>feat</li> <li>fix</li> <li>docs</li> <li>style</li> <li>refactor</li> <li>perf</li> <li>test</li> <li>build</li> <li>ci</li> <li>chore</li> <li>revert</li> </ul>"},{"location":"Development/contributing/#semantic-versioning","title":"Semantic Versioning","text":"<p>As mentioned in the Conventional Commits section, semantic versioning is planned to be employed on app releases. A GitHub app, 'Semantic-prs' is used to ensure at least pull-requests use conventional commit style so versioning can be reliably automated. As development is still early, major functionality is still being fleshed out and major backwards incompatible changes are likely for the time being. The official version remains at 0.1.0 for now with git commit hashes being used for meaningful version-tracking and constrains for the time being. After the first major release, Proxima will follow semantic versioning.</p>"},{"location":"Development/contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Pre-commit hooks are recommended, but are opt-in, since individual developers must set them up. They're installed with the other Poetry development dependencies, but must be set up manually with <code>pre-commit install</code>. From then on, any commit will run through a series of local checks. If fixes are automatically applied, simply stage changes and commit again. Pre-commit checks are defined in <code>.pre-commit-config.yaml</code></p>"},{"location":"Development/contributing/#pre-commit-ci","title":"Pre-commit CI","text":"<p>Alongside pre-commit hooks is pre-commit CI, which runs as a GitHub app. So long as pre-commit hooks are set-up properly, pre-commit CI won't catch anything, otherwise it will show a failed check. Pre-commit CI also uses <code>.pre-commit-config.yaml</code></p>"},{"location":"Development/contributing/#automatic-issues-from-todos","title":"Automatic Issues from TODOs","text":"<p>This repository uses a GitHub Action to convert in-code todo comments into issues. Todos should be written like this; with a short title,  description and label when necessary:</p> <pre><code># TODO: Post-encode linking not working\n# Seems like this function is being passed an empty list?\n# labels: bug\n</code></pre> <p>Once pushed to the repo, these TODOS are automatically pulled out and turned into issues, with the title for the issue title, the remaining lines as a description, a short code excerpt embedded and the label set appropriately. The idea for these TODOs is to quickly track short-term problems that need addressing. An issue that arises when these TODOs stick-around is they cross-pollinate branches, creating multiple issues (which are branch agnostic). The key takeaway here is that ideally no TODOs should remain before a pull-request. Further documentation for this workflow is available here: https://github.com/alstr/todo-to-issue-action</p>"},{"location":"Development/philosophy/","title":"Philosophy","text":""},{"location":"Development/philosophy/#what-proxima-is-not","title":"What Proxima is not","text":"<p>The desire has always been for a distributed proxy encoding application. Proxima provides a good example for handling Resolve's data and passing it to a distribute framework. Perhaps it has potential as a starting point for integrating Resolve with other distributed applications, like:</p> <ul> <li>stabilisation</li> <li>optical flow </li> <li>machine learning</li> </ul> <p>Proxima itself should probably only ever deal with proxies though. Its core integration mechanism is simple: linking proxies.  Some specialised handlers would be required to integrate new video assets non-destructively. Integration through Fusion may be a good route, but one that deviates too far from Proxima's core strengths.   </p>"},{"location":"User%20Guide/Getting%20Started/","title":"Getting Started","text":""},{"location":"User%20Guide/Getting%20Started/#first-run","title":"First Run","text":"<p>Assuming you've followed installation instructions and Proxima is up and running, you can begin to try it out. Run <code>proxima</code> in your terminal. </p> <p><pre><code>$ proxima\n\n\u274c  Checking settings...\nNo user settings found at path 'C:\\Users\\in03\\.config\\proxima\\user_settings.yml'\nLoad defaults now for adjustment? [y/n]:\n</code></pre> Because no configuration file exists yet, Proxima will ask to create one for you and open it:</p> <pre><code>---  # Proxima User configuration file\n\n# NOTE: \n# Proxy paths, codecs, resolution, filters, etc are all inherited from the queuer's user configuration.\n# 'Celery' and 'Worker' settings are pulled from local user configuration.\n\napp:\nloglevel: INFO\ncheck_for_updates: true\nupdate_check_url: \"https://github.com/in03/proxima\" # If you fork the repo, change this to your fork\ndisable_version_constrain: false # DANGEROUS! Allows any version of worker to take jobs. Must be set on queuer and worker. \n\npaths:\nproxy_path_root: R:/ProxyMedia  # Proxy media retains source folder structure\nffmpeg_logfile_path: R:/ProxyMedia/@logs\n\nproxy:\nffmpeg_loglevel: error # \"quiet\", \"panic\", \"fatal\", \"error\", \"warning\", \"info\", \"verbose\", \"debug\"\ncodec: prores\nvertical_res: \"720\"\nprofile: \"0\" #422 proxy\npix_fmt: yuv422p\naudio_codec: pcm_s16le\naudio_samplerate: \"48000\"\nmisc_args: [-hide_banner, -stats]\next: .mov\n\nfilters:\n# Remove elements from lists to disable filter\nextension_whitelist : [.mov, .mp4, .mxf, .avi] framerate_whitelist : [24, 25, 30, 50, 60]\n\nbroker:\nurl:  redis://192.168.1.123:6379/0\njob_expires: 3600 # 1 hour (cleared if not received by worker)\nresult_expires: 86400 # 1 day (Needed for webapp monitor)\n\nworker:\nloglevel: INFO\nterminal_args: [] # use alternate shell? Recommend windows terminal (\"wt\") on Windows.\ncelery_args: [-l, INFO, -P, solo, --without-mingle, --without-gossip]\n</code></pre> <p>If this all looks like a little much for you right now, don't stress. We'll walk through them together.</p>"},{"location":"User%20Guide/Getting%20Started/#starting-workers","title":"Starting Workers","text":"<p>You can start workers on your local machine with <code>proxima work</code>. Proxima will ask you how many workers you'd like to start,  defaulting to two workers less than the amount of logical cores your CPU has. For example on a 12 core machine, Proxima will recommend 10 workers.</p> <p>Example - Starting one worker: <pre><code>$ proxima work 1\n\n\u2705  Checking settings...\n\n                 _\n ___ ___ ___ _ _|_|_____ ___ \n| . |  _| . |_'_| |     | .'|\n|  _|_| |___|_,_|_|_|_|_|__,|\n|_|\n\n\nGit build (cloned \ud83d\udee0 ) '517cb5d' | Version constraint key 'quizically-queer-quail'\nRun proxima --help for a list of commands\n\n\nStarting workers! \ud83d\udc77 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[13:25:30] INFO     Consuming from queue with key: 'quizically-queer-quail'        \n\n           INFO     NEW WORKER- 3buoc@EMA                                     \n</code></pre></p>"},{"location":"User%20Guide/Getting%20Started/#the-version-constraint-key","title":"The version constraint key","text":"<p><pre><code>$ proxima work 1\n\n\n                 _\n ___ ___ ___ _ _|_|_____ ___ \n| . |  _| . |_'_| |     | .'|\n|  _|_| |___|_,_|_|_|_|_|__,|\n|_|\n\n\nGit build (cloned \ud83d\udee0 ) '517cb5d' | Version constraint key 'quizically-queer-quail'\nRun proxima --help for a list of commands\n</code></pre> Once started, workers will consume jobs queued with the version constraint key <code>quizically-queer-quail</code>. This key is used to prevent workers from consuming jobs from incompatible queuers. Using a unique key like this allows cloned git builds, installed git builds and PyPi release builds to work well together so long as the code is the same. It's also possible to alter this key to force different versions to work together, but not recommended.</p>"},{"location":"User%20Guide/Installation/","title":"Reference","text":"<p>::: proxima.app.checks.WorkerCheck     handler: python</p>"}]}